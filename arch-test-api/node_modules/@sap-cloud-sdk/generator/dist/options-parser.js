"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseOptions = exports.getOptionsWithoutDefaults = void 0;
const util_1 = require("@sap-cloud-sdk/util");
const logger = (0, util_1.createLogger)('generator-options');
/**
 * @internal
 * Remove defaults from CLI options. This is necessary to handle default setting on our own.
 * @param options - CLI options, record, that maps option name to option config.
 * @returns CLI options without default values.
 */
function getOptionsWithoutDefaults(options) {
    return Object.entries(options).reduce((optionsWithoutDefaults, [name, option]) => {
        const { default: def, ...optionWithoutDefault } = option;
        const describe = def === undefined
            ? optionWithoutDefault.describe
            : `${optionWithoutDefault.describe}\n[Default: ${def}]`;
        return {
            ...optionsWithoutDefaults,
            [name]: {
                ...optionWithoutDefault,
                describe
            }
        };
    }, {});
}
exports.getOptionsWithoutDefaults = getOptionsWithoutDefaults;
/**
 * @internal
 * Parse options for programmatic and CLI use.
 * Warn, if deprecated options are used or duplicate.
 * Adds defaults for options not set by the user.
 * @param options - Available CLI options along with their configuration.
 * @param userOptions - Options as set by user, either through the CLI or programmatically.
 * @returns Parsed options with default values.
 */
function parseOptions(options, userOptions) {
    return new OptionsParser(options, userOptions).parseOptions();
}
exports.parseOptions = parseOptions;
class OptionsParser {
    constructor(options, userOptions) {
        this.options = options;
        this.userOptions = userOptions;
    }
    parseOptions() {
        this.warnIfDeprecatedOptionsUsed();
        this.warnIfDuplicateOptionsUsed();
        const parsedOptions = this.sanitizeIfReplacedOptionsUsed();
        return this.addDefaults(parsedOptions);
    }
    addDefaults(parsedOptions) {
        Object.entries(this.options).forEach(([name, option]) => {
            var _a;
            if ('default' in option) {
                parsedOptions[name] = (_a = parsedOptions[name]) !== null && _a !== void 0 ? _a : option.default;
            }
        });
        return parsedOptions;
    }
    getDeprecatedOptionsInUse() {
        return Object.keys(this.options)
            .filter(name => this.options[name].deprecated)
            .filter(name => Object.keys(this.userOptions).includes(name));
    }
    getReplacedOptionsUsed() {
        return Object.keys(this.options)
            .filter(name => this.options[name].replacedBy)
            .filter(name => Object.keys(this.userOptions).includes(name));
    }
    getReplacingOptionName(replacedOptionName) {
        const replacingOptionName = this.options[replacedOptionName].replacedBy;
        if (!replacingOptionName) {
            throw new Error(`Cannot get replaced option for deprecated option ${replacedOptionName}.`);
        }
        return replacingOptionName;
    }
    getDuplicateOptionsUsed() {
        const oldOptionsUsed = this.getReplacedOptionsUsed();
        if (oldOptionsUsed.length) {
            const oldNewNames = oldOptionsUsed.map(name => ({
                oldName: name,
                newName: this.getReplacingOptionName(name)
            }));
            return oldNewNames.filter(({ newName }) => Object.keys(this.userOptions).includes(newName));
        }
        return [];
    }
    /**
     * @internal
     * Logs a warning if deprecated options are used.
     * @param args - Either the command line arguments or the config passed for programmatic use. An array implicates command line arguments, while objects represent the programmatic config.
     * @param options - Available generator options.
     */
    warnIfDeprecatedOptionsUsed() {
        const deprecatedOptionsInUse = this.getDeprecatedOptionsInUse();
        if (deprecatedOptionsInUse.length) {
            const logs = deprecatedOptionsInUse
                .map(name => `\t${name}: ${this.options[name].deprecated}`)
                .join('\n');
            logger.warn(`Deprecated options used:\n${logs}`);
        }
    }
    warnIfDuplicateOptionsUsed() {
        const duplicateOptionsUsed = this.getDuplicateOptionsUsed();
        if (duplicateOptionsUsed.length) {
            const log = duplicateOptionsUsed
                .map(({ oldName, newName }) => `\t${oldName} was replaced by ${newName}.`)
                .join('\n');
            logger.warn(`Duplicate options used:\n${log}`);
        }
    }
    sanitizeIfReplacedOptionsUsed() {
        const replacedOptionsUsed = this.getReplacedOptionsUsed();
        return Object.entries(this.userOptions).reduce((opts, [name, value]) => {
            if (replacedOptionsUsed.includes(name)) {
                const replacedByName = this.getReplacingOptionName(name);
                return replacedByName in this.userOptions
                    ? // ignore the deprecated value => it will be set by the correct option
                        opts
                    : // set the replaced value for the new name
                        { ...opts, [replacedByName]: value };
            }
            return { ...opts, [name]: value };
        }, {});
    }
}
//# sourceMappingURL=options-parser.js.map