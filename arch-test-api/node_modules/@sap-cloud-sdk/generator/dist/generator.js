"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSourcesForService = exports.generateProject = exports.transpileDirectories = exports.getInstallODataErrorMessage = exports.generateWithParsedOptions = exports.generate = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const util_1 = require("@sap-cloud-sdk/util");
const fs_extra_1 = require("fs-extra");
const ts_morph_1 = require("ts-morph");
const glob_1 = require("glob");
const internal_1 = require("@sap-cloud-sdk/generator-common/internal");
const file_1 = require("./batch/file");
const file_2 = require("./complex-type/file");
const file_3 = require("./entity/file");
const file_generator_1 = require("./file-generator");
const generator_options_1 = require("./generator-options");
const generator_utils_1 = require("./generator-utils");
const service_generator_1 = require("./service-generator");
const file_4 = require("./request-builder/file");
const service_mapping_1 = require("./service-mapping");
const csn_1 = require("./service/csn");
const index_file_1 = require("./service/index-file");
const package_json_1 = require("./service/package-json");
const readme_1 = require("./service/readme");
const ts_config_1 = require("./service/ts-config");
const file_5 = require("./operations/file");
const file_6 = require("./enum-type/file");
const sdk_metadata_1 = require("./sdk-metadata");
const generator_without_ts_morph_1 = require("./generator-without-ts-morph");
const file_7 = require("./generator-without-ts-morph/service/file");
const options_parser_1 = require("./options-parser");
const { mkdir, readdir } = fs_1.promises;
const logger = (0, util_1.createLogger)({
    package: 'generator',
    messageContext: 'generator'
});
/**
 * Main entry point for the OData client generation.
 * Generates models and API files.
 * @param options - Options to configure generation.
 */
async function generate(options) {
    const parsedOptions = (0, options_parser_1.parseOptions)(generator_options_1.generatorOptionsCli, options);
    return generateWithParsedOptions(parsedOptions);
}
exports.generate = generate;
/**
 * @internal
 * This is the main entry point for generation, after options were parsed - either from the CLI or from the programmatically passed configuration.
 */
async function generateWithParsedOptions(options) {
    var _a;
    const projectAndServices = await generateProject(options);
    if (!projectAndServices) {
        throw Error('The project is undefined.');
    }
    const services = projectAndServices.services;
    await generateFilesWithoutTsMorph(services, options);
    if (options.generateJs) {
        const directories = services
            .filter(async (service) => {
            const files = await readdir(resolvePath(service.directoryName, options));
            return files.includes('tsconfig.json');
        })
            .map(service => resolvePath(service.directoryName, options));
        const chunks = (0, util_1.splitInChunks)(directories, options.transpilationProcesses || generator_options_1.defaultValueProcessesJsGeneration);
        try {
            await chunks.reduce((all, chunk) => all.then(() => transpileDirectories(chunk, options)), Promise.resolve());
        }
        catch (err) {
            if ((_a = err.message) === null || _a === void 0 ? void 0 : _a.includes('error TS2307')) {
                throw new util_1.ErrorWithCause(getInstallODataErrorMessage(projectAndServices), err);
            }
            throw err;
        }
    }
}
exports.generateWithParsedOptions = generateWithParsedOptions;
/**
 * @internal
 * @param projectAndServices - Generated project with services.
 * @returns An error message with a recommendation to install specific SDK packages.
 */
function getInstallODataErrorMessage(projectAndServices) {
    const hasV2 = projectAndServices.services.some(service => service.oDataVersion === 'v2');
    const hasV4 = projectAndServices.services.some(service => service.oDataVersion === 'v4');
    if (hasV2 && hasV4) {
        return 'Did you forget to install "@sap-cloud-sdk/odata-v2" and "@sap-cloud-sdk/odata-v4"?';
    }
    return `Did you forget to install "@sap-cloud-sdk/odata-v${hasV2 ? '2' : '4'}"?`;
}
exports.getInstallODataErrorMessage = getInstallODataErrorMessage;
/**
 * @internal
 */
async function transpileDirectories(directories, options) {
    return Promise.all(directories.map(async (directory) => {
        const [compilerOptions, createFileOptions] = await Promise.all([
            (0, internal_1.readCompilerOptions)(directory),
            getFileCreationOptions(options)
        ]);
        return (0, internal_1.transpileDirectory)(directory, {
            compilerOptions,
            createFileOptions
        });
    }));
}
exports.transpileDirectories = transpileDirectories;
/**
 * @internal
 */
async function generateProject(options) {
    options = sanitizeOptions(options);
    const services = parseServices(options);
    if (!services.length) {
        logger.warn('No services parsed.');
        return;
    }
    if (options.clearOutputDir) {
        (0, fs_extra_1.emptyDirSync)(options.outputDir.toString());
    }
    const project = new ts_morph_1.Project(projectOptions());
    const promises = services.map(service => generateSourcesForService(service, project, options));
    await Promise.all(promises);
    if (!options.serviceMapping) {
        throw Error('The service mapping is undefined.');
    }
    project.createSourceFile((0, path_1.resolve)(options.serviceMapping.toString()), (0, service_mapping_1.serviceMappingFile)(services), { overwrite: true });
    return { project, services };
}
exports.generateProject = generateProject;
async function generateFilesWithoutTsMorph(services, options) {
    const promises = services.flatMap(service => [
        generateEntityApis(service, options),
        generateServiceFile(service, options),
        generateIncludes(service, options)
    ]);
    await Promise.all(promises);
}
async function getFileCreationOptions(options) {
    var _a;
    return {
        prettierOptions: await (0, internal_1.readPrettierConfig)((_a = options.prettierConfig) === null || _a === void 0 ? void 0 : _a.toString()),
        overwrite: options.overwrite
    };
}
async function generateIncludes(service, options) {
    if (options.include) {
        const includeDir = (0, path_1.resolve)(options.inputDir.toString(), options.include)
            .split(path_1.sep)
            .join(path_1.posix.sep);
        const serviceDir = resolvePath(service.directoryName, options);
        const files = new glob_1.GlobSync(includeDir).found;
        await (0, internal_1.copyFiles)(files, serviceDir, options.overwrite);
    }
}
async function generateServiceFile(service, options) {
    const serviceDir = resolvePath(service.directoryName, options);
    const createFileOptions = await getFileCreationOptions(options);
    await (0, internal_1.createFile)(serviceDir, 'service.ts', (0, file_7.serviceFile)(service), createFileOptions);
}
async function generateEntityApis(service, options) {
    const createFileOptions = await getFileCreationOptions(options);
    await Promise.all(service.entities.map(entity => (0, internal_1.createFile)(resolvePath(service.directoryName, options), `${entity.className}Api.ts`, (0, generator_without_ts_morph_1.entityApiFile)(entity, service), createFileOptions)));
}
/**
 * @internal
 */
async function generateSourcesForService(service, project, options) {
    var _a, _b;
    const serviceDirPath = resolvePath(service.directoryName, options);
    const serviceDir = project.createDirectory(serviceDirPath);
    const createFileOptions = await getFileCreationOptions(options);
    if (!(0, fs_1.existsSync)(serviceDirPath)) {
        await mkdir(serviceDirPath, { recursive: true });
    }
    const filePromises = [];
    logger.info(`[${service.originalFileName}] Generating entities ...`);
    if (options.packageJson) {
        filePromises.push((0, internal_1.createFile)(serviceDirPath, 'package.json', await (0, package_json_1.packageJson)({
            npmPackageName: service.npmPackageName,
            version: await (0, internal_1.getVersionForClient)(options.packageVersion),
            sdkVersion: await (0, internal_1.getSdkVersion)(),
            description: (0, internal_1.packageDescription)(service.speakingModuleName),
            sdkAfterVersionScript: options.sdkAfterVersionScript,
            oDataVersion: service.oDataVersion,
            license: options.licenseInPackageJson
        }), createFileOptions));
    }
    filePromises.push((0, internal_1.createFile)(serviceDirPath, 'tsconfig.json', (0, ts_config_1.tsConfig)(), createFileOptions));
    if ((0, generator_utils_1.hasEntities)(service)) {
        logger.info(`[${service.originalFileName}] Generating batch request builder ...`);
        filePromises.push((0, file_generator_1.sourceFile)(serviceDir, 'BatchRequest', (0, file_1.batchSourceFile)(service), createFileOptions));
    }
    service.entities.forEach(entity => {
        logger.info(`Generating entity: ${entity.className}...`);
        filePromises.push((0, file_generator_1.sourceFile)(serviceDir, entity.className, (0, file_3.entitySourceFile)(entity, service), createFileOptions));
        filePromises.push((0, file_generator_1.sourceFile)(serviceDir, `${entity.className}RequestBuilder`, (0, file_4.requestBuilderSourceFile)(entity, service.oDataVersion), createFileOptions));
    });
    service.enumTypes.forEach(enumType => {
        logger.info(`[${service.originalFileName}] Generating enum type ${enumType.originalName} ...`);
        filePromises.push((0, file_generator_1.sourceFile)(serviceDir, enumType.typeName, (0, file_6.enumTypeSourceFile)(enumType), createFileOptions));
    });
    service.complexTypes.forEach(complexType => {
        logger.info(`[${service.originalFileName}] Generating complex type ${complexType.originalName} ...`);
        filePromises.push((0, file_generator_1.sourceFile)(serviceDir, complexType.typeName, (0, file_2.complexTypeSourceFile)(complexType, service.oDataVersion), createFileOptions));
    });
    if ((_a = service.functionImports) === null || _a === void 0 ? void 0 : _a.length) {
        logger.info(`[${service.originalFileName}] Generating function imports ...`);
        filePromises.push((0, file_generator_1.sourceFile)(serviceDir, 'function-imports', (0, file_5.operationsSourceFile)(service, 'function'), createFileOptions));
    }
    if ((_b = service.actionImports) === null || _b === void 0 ? void 0 : _b.length) {
        logger.info(`[${service.originalFileName}] Generating action imports ...`);
        filePromises.push((0, file_generator_1.sourceFile)(serviceDir, 'action-imports', (0, file_5.operationsSourceFile)(service, 'action'), createFileOptions));
    }
    filePromises.push((0, file_generator_1.sourceFile)(serviceDir, 'index', (0, index_file_1.indexFile)(service), createFileOptions));
    if (options.readme) {
        logger.info(`[${service.originalFileName}] Generating readme ...`);
        filePromises.push((0, internal_1.createFile)(serviceDirPath, 'README.md', (0, readme_1.readme)(service, options.s4hanaCloud), createFileOptions));
    }
    if (options.generateCSN) {
        try {
            logger.info(`[${service.originalFileName}] Generating ${service.directoryName}-csn.json ...`);
            filePromises.push((0, internal_1.createFile)(serviceDirPath, `${service.directoryName}-csn.json`, await (0, csn_1.csn)(service), createFileOptions));
        }
        catch (e) {
            logger.error(`CSN creation for service ${service.originalFileName} failed. Original error: ${e.message}`);
        }
    }
    if (options.generateSdkMetadata) {
        const { clientFileName } = (0, internal_1.getSdkMetadataFileNames)(service.originalFileName);
        logger.info(`Generating sdk client metadata ${clientFileName}...`);
        const path = (0, path_1.resolve)((0, path_1.dirname)(service.edmxPath.toString()), 'sdk-metadata');
        if (!(0, fs_1.existsSync)(path)) {
            await mkdir(path);
        }
        filePromises.push((0, internal_1.createFile)(path, clientFileName, JSON.stringify(await (0, sdk_metadata_1.sdkMetadata)(service), null, 2), createFileOptions));
    }
    await Promise.all(filePromises);
}
exports.generateSourcesForService = generateSourcesForService;
function projectOptions() {
    return {
        skipAddingFilesFromTsConfig: true,
        manipulationSettings: {
            indentationText: ts_morph_1.IndentationText.TwoSpaces,
            insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: true,
            quoteKind: ts_morph_1.QuoteKind.Single
        },
        compilerOptions: {
            target: ts_morph_1.ScriptTarget.ES2019,
            module: ts_morph_1.ModuleKind.CommonJS,
            declaration: true,
            declarationMap: true,
            sourceMap: true,
            diagnostics: true,
            moduleResolution: ts_morph_1.ModuleResolutionKind.NodeJs,
            esModuleInterop: true,
            inlineSources: false,
            noImplicitAny: true
        }
    };
}
function parseServices(options) {
    const services = (0, service_generator_1.parseAllServices)(options);
    if (!services.length) {
        logger.warn('No service definition files found.');
        return [];
    }
    return services;
}
function sanitizeOptions(options) {
    options.serviceMapping =
        options.serviceMapping ||
            (0, path_1.resolve)(options.inputDir.toString(), 'service-mapping.json');
    return options;
}
function resolvePath(path, options) {
    return (0, path_1.resolve)(options.outputDir.toString(), path.toString());
}
//# sourceMappingURL=generator.js.map