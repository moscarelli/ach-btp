"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getServiceName = exports.parseService = exports.parseAllServices = void 0;
const generator_utils_1 = require("./generator-utils");
const global_name_formatter_1 = require("./global-name-formatter");
const input_path_provider_1 = require("./input-path-provider");
const service_mapping_1 = require("./service-mapping");
const service_name_formatter_1 = require("./service-name-formatter");
const edmx_file_reader_1 = require("./edmx-parser/edmx-file-reader");
const swagger_parser_1 = require("./swagger-parser/swagger-parser");
const swagger_util_1 = require("./swagger-parser/swagger-util");
const edmx_to_vdm_util_1 = require("./edmx-to-vdm/edmx-to-vdm-util");
const v2_1 = require("./edmx-to-vdm/v2");
const v4_1 = require("./edmx-to-vdm/v4");
class ServiceGenerator {
    constructor(options) {
        this.options = options;
        this.serviceMapping = (0, service_mapping_1.readServiceMapping)(options);
        this.globalNameFormatter = new global_name_formatter_1.GlobalNameFormatter(this.serviceMapping);
    }
    withServiceMapping(serviceMapping) {
        this.serviceMapping = serviceMapping;
        return this;
    }
    withGlobalNameFormatter(globalNameFormatter) {
        this.globalNameFormatter = globalNameFormatter;
        return this;
    }
    generateAllServices() {
        return (0, input_path_provider_1.inputPaths)(this.options.inputDir, this.options.useSwagger).map(p => this.generateService(p));
    }
    generateService(serviceDefinitionPaths) {
        const serviceMetadata = this.readEdmxAndSwaggerFile(serviceDefinitionPaths);
        const vdmServicePackageMetaData = this.getServicePackageMetaData(serviceMetadata, serviceDefinitionPaths);
        const vdmServiceEntities = (0, edmx_to_vdm_util_1.isV2Metadata)(serviceMetadata.edmx)
            ? (0, v2_1.getServiceEntitiesV2)(serviceMetadata, vdmServicePackageMetaData.className)
            : (0, v4_1.getServiceEntitiesV4)(serviceMetadata, vdmServicePackageMetaData.className);
        return {
            ...vdmServicePackageMetaData,
            ...vdmServiceEntities
        };
    }
    getServicePackageMetaData(serviceMetadata, serviceDefinitionPaths) {
        const directoryName = this.globalNameFormatter.uniqueDirectoryName(service_name_formatter_1.ServiceNameFormatter.originalToServiceName(serviceMetadata.edmx.namespaces.length === 1
            ? serviceMetadata.edmx.namespaces[0]
            : serviceMetadata.edmx.fileName), serviceMetadata.edmx.fileName);
        const npmPackageName = this.globalNameFormatter.uniqueNpmPackageName((0, generator_utils_1.npmCompliantName)(directoryName), serviceMetadata.edmx.fileName);
        const speakingModuleName = service_name_formatter_1.ServiceNameFormatter.directoryToSpeakingModuleName(directoryName);
        const className = `${speakingModuleName.replace(/ /g, '')}`;
        return {
            oDataVersion: serviceMetadata.edmx.oDataVersion,
            namespaces: serviceMetadata.edmx.namespaces,
            originalFileName: serviceMetadata.edmx.fileName,
            directoryName,
            npmPackageName,
            speakingModuleName,
            servicePath: (0, service_mapping_1.getServicePath)(serviceMetadata, this.serviceMapping[serviceMetadata.edmx.fileName]),
            edmxPath: serviceDefinitionPaths.edmxPath,
            apiBusinessHubMetadata: (0, swagger_util_1.apiBusinessHubMetadata)(serviceMetadata.swagger),
            className
        };
    }
    readEdmxAndSwaggerFile(serviceDefinitionPaths) {
        const serviceMetadata = {
            edmx: (0, edmx_file_reader_1.readEdmxFile)(serviceDefinitionPaths.edmxPath)
        };
        if (serviceDefinitionPaths.swaggerPath) {
            serviceMetadata.swagger = (0, swagger_parser_1.readSwaggerFile)(serviceDefinitionPaths.swaggerPath);
        }
        return serviceMetadata;
    }
}
/**
 * @param options - Generator options
 * @returns the parsed services
 * @internal
 */
function parseAllServices(options) {
    return new ServiceGenerator(options).generateAllServices();
}
exports.parseAllServices = parseAllServices;
/**
 * @param serviceDefinitionPaths - Path to the service definition
 * @param options - Generator options
 * @param mappings - mappings for VDM service names to desired name
 * @param globalNameFormatter - Instance of global name formatter to be used for the parsing process
 * @returns the parsed service
 * @internal
 */
function parseService(serviceDefinitionPaths, options, mappings, globalNameFormatter) {
    return new ServiceGenerator(options)
        .withServiceMapping(mappings)
        .withGlobalNameFormatter(globalNameFormatter)
        .generateService(serviceDefinitionPaths);
}
exports.parseService = parseService;
/**
 * @internal
 */
function getServiceName(service) {
    return service.namespaces.length === 1
        ? service.namespaces[0]
        : service.originalFileName;
}
exports.getServiceName = getServiceName;
//# sourceMappingURL=service-generator.js.map