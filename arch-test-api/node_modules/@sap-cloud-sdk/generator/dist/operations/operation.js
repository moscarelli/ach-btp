"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.operationFunction = exports.operationFunctionBase = void 0;
const ts_morph_1 = require("ts-morph");
const voca_1 = __importDefault(require("voca"));
const common_1 = require("../edmx-to-vdm/common");
const request_builder_arguments_1 = require("./request-builder-arguments");
const return_type_1 = require("./return-type");
const parameterName = 'parameters';
/**
 * @internal
 * Returns a function like declaration representation for an action or function.
 * Reusable for bound and unbound functions.
 */
function operationFunctionBase(operation, service) {
    const { isBound } = operation;
    return {
        name: isBound
            ? operation.name
            : `${operation.name}<DeSerializersT extends DeSerializers = DefaultDeSerializers>`,
        parameters: [
            {
                name: parameterName,
                type: `${operation.parametersTypeName}<${isBound ? 'T' : 'DeSerializersT'}>`
            },
            {
                name: isBound ? 'deSerializers?' : 'deSerializers',
                type: isBound ? 'T' : 'DeSerializersT',
                initializer: isBound ? undefined : 'defaultDeSerializers as any'
            }
        ],
        returnType: (0, return_type_1.operationReturnType)(operation),
        statements: getOperationStatements(operation, service),
        docs: [
            [
                getDocDescription(operation),
                `@param parameters - Object containing all parameters for the ${operation.type}.`,
                '@returns A request builder that allows to overwrite some of the values and execute the resulting request.'
            ].join('\n')
        ]
    };
}
exports.operationFunctionBase = operationFunctionBase;
/**
 * @internal
 * Returns a function declaration representation for an action or function.
 */
function operationFunction(operation, service) {
    return {
        kind: ts_morph_1.StructureKind.Function,
        isExported: true,
        ...operationFunctionBase(operation, service)
    };
}
exports.operationFunction = operationFunction;
function getDocDescription({ description, returnType, type }) {
    return `${description} ${(0, common_1.isEntityNotDeserializable)(returnType)
        ? `The 'execute' method does not exist when using this ${type} import. Please use the 'executeRaw' for getting the raw response.`
        : ''}`;
}
function getOperationStatements(operation, service) {
    const requestBuilderName = `${operation.isBound ? 'Bound' : ''}${voca_1.default.capitalize(operation.type)}ImportRequestBuilder`;
    const paramsLines = (operation.parameters || []).map(param => `${param.parameterName}: new ${voca_1.default.capitalize(operation.type)}ImportParameter('${param.originalName}', '${param.edmType}', ${parameterName}.${param.parameterName})`);
    const params = `const params = {\n${paramsLines.join(',\n')}\n};`;
    let parameters = (0, request_builder_arguments_1.getRequestBuilderArgumentsBase)(operation, service);
    if (operation.type === 'function' && service.oDataVersion === 'v2') {
        parameters = [`'${operation.httpMethod}'`, ...parameters];
    }
    const returnStatement = `return new ${requestBuilderName}(${parameters.join(', ')});`;
    return `${params}\n\n${returnStatement}`;
}
//# sourceMappingURL=operation.js.map