"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.operationImportDeclarations = void 0;
const ts_morph_1 = require("ts-morph");
const voca_1 = __importDefault(require("voca"));
const vdm_types_1 = require("../vdm-types");
const imports_1 = require("../imports");
const common_1 = require("../edmx-to-vdm/common");
const response_transformer_function_1 = require("./response-transformer-function");
function complexTypeRelatedImports(returnTypes) {
    return returnTypes.some(returnType => returnType.returnTypeCategory === vdm_types_1.VdmReturnTypeCategory.COMPLEX_TYPE)
        ? ['entityDeserializer']
        : [];
}
function edmRelatedImports(returnTypes) {
    return returnTypes.some(returnType => returnType.returnTypeCategory === vdm_types_1.VdmReturnTypeCategory.EDM_TYPE)
        ? ['edmToTs']
        : [];
}
function responseTransformerImports(returnTypes) {
    return returnTypes.map(returnType => (0, common_1.isEntityNotDeserializable)(returnType)
        ? 'throwErrorWhenReturnTypeIsUnionType'
        : (0, response_transformer_function_1.responseTransformerFunctionName)(returnType));
}
function returnTypeImports(returnTypes) {
    return (0, imports_1.mergeImportDeclarations)(returnTypes
        .filter(returnType => returnType.returnTypeCategory !== vdm_types_1.VdmReturnTypeCategory.EDM_TYPE &&
        returnType.returnTypeCategory !== vdm_types_1.VdmReturnTypeCategory.VOID &&
        returnType.returnTypeCategory !== vdm_types_1.VdmReturnTypeCategory.NEVER)
        .reduce((imports, returnType) => [...imports, ...returnTypeImport(returnType)], []));
}
function returnTypeImport(returnType) {
    const typeImports = [
        {
            kind: ts_morph_1.StructureKind.ImportDeclaration,
            namedImports: [returnType.returnType],
            moduleSpecifier: `./${returnType.returnType}`
        }
    ];
    if (returnType.returnTypeCategory === vdm_types_1.VdmReturnTypeCategory.ENTITY) {
        return [
            ...typeImports,
            {
                kind: ts_morph_1.StructureKind.ImportDeclaration,
                namedImports: [`${returnType.returnType}Api`],
                moduleSpecifier: `./${returnType.returnType}Api`
            }
        ];
    }
    return typeImports;
}
/**
 * @internal
 */
function operationImportDeclarations({ oDataVersion, className }, type, operations = []) {
    if (!operations.length) {
        return [];
    }
    const parameters = operations.flatMap(({ parameters: params }) => params);
    const returnTypes = operations.map(({ returnType }) => returnType);
    const includesBound = !!operations.filter(operation => operation.isBound)
        .length;
    const includesUnbound = !!operations.filter(operation => !operation.isBound)
        .length;
    const hasOperationWithParameters = !!operations.filter(operation => operation.parameters.length > 0 && operation.type === type).length;
    if (includesUnbound && includesBound) {
        throw new Error('Bound and unbound operations found in generation - this should not happen.');
    }
    const serviceImport = includesBound
        ? []
        : [
            {
                kind: ts_morph_1.StructureKind.ImportDeclaration,
                namedImports: [voca_1.default.decapitalize(className)],
                moduleSpecifier: './service'
            }
        ];
    return [
        ...(0, imports_1.externalImportDeclarations)(parameters),
        (0, imports_1.odataImportDeclaration)([
            ...edmRelatedImports(returnTypes),
            ...complexTypeRelatedImports(returnTypes),
            ...responseTransformerImports(returnTypes),
            'DeSerializers',
            'DefaultDeSerializers',
            'defaultDeSerializers',
            ...(0, imports_1.propertyTypeImportNames)(parameters),
            ...(hasOperationWithParameters
                ? [`${voca_1.default.capitalize(type)}ImportParameter`]
                : []),
            ...(includesUnbound
                ? [`${voca_1.default.capitalize(type)}ImportRequestBuilder`]
                : []),
            ...(includesBound
                ? [`Bound${voca_1.default.capitalize(type)}ImportRequestBuilder`]
                : [])
        ], oDataVersion),
        ...serviceImport,
        ...returnTypeImports(returnTypes)
    ];
}
exports.operationImportDeclarations = operationImportDeclarations;
//# sourceMappingURL=import.js.map